#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of the distrobox project:
#    https://github.com/89luca89/distrobox
#
# Copyright (C) 2021 distrobox contributors
#
# distrobox is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# distrobox is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with distrobox; if not, see <http://www.gnu.org/licenses/>.

# POSIX
# Expected env variables:
#	HOME
#	USER
#	SHELL

set -x 
set -e

trap '[ "$?" -ne 0 ] && printf "Error: An error occurred\n"' EXIT

# Redirect stderr to stdout as podman by default logs stderr as priority 3 journald errors.
# Github issue: https://github.com/containers/podman/issues/20728
exec 2>&1

# Defaults
container_additional_packages=""
init_hook=""
nvidia=0
pre_init_hook=""
rootful=0
upgrade=0
verbose=0
version="1.8.1.2"

# show_help will print usage to stdout.
# Arguments:
#   None
# Expected global variables:
#   version: distrobox version
# Expected env variables:
#   USER
#   HOME
# Outputs:
#   print usage with examples.
show_help()
{
	cat << EOF
distrobox version: ${version}

Usage:

	distrobox-init --name ${USER} --user $(id -ru) --group $(id -rg) --home ${HOME}

Options:

	--name/-n:		user name
	--user/-u:		uid of the user
	--group/-g:		gid of the user
	--home/-d:		path/to/home of the user
	--help/-h:		show this message
	--additional-packages:	packages to install in addition
	--pre-init-hooks:	commands to execute prior to init
	--nvidia:		try to integrate host's nVidia drivers in the guest
	--upgrade/-U:		run init in upgrade mode
	--verbose/-v:		show more verbosity
	--version/-V:		show version
	--:			end arguments execute the rest as command to execute during init
EOF
}

# Parse arguments
while :; do
	case $1 in
		-h | --help)
			# Call a "show_help" function to display a synopsis, then exit.
			show_help
			exit 0
			;;
		-v | --verbose)
			shift
			verbose=1
			;;
		-V | --version)
			printf "distrobox: %s\n" "${version}"
			exit 0
			;;
		-U | --upgrade)
			shift
			upgrade=1
			;;
		-n | --name)
			if [ -n "$2" ]; then
				container_user_name="$2"
				shift
				shift
			fi
			;;
		-d | --home)
			if [ -n "$2" ]; then
				container_user_home="$2"
				shift
				shift
			fi
			;;
		-u | --user)
			if [ -n "$2" ]; then
				container_user_uid="$2"
				shift
				shift
			fi
			;;
		-g | --group)
			if [ -n "$2" ]; then
				container_user_gid="$2"
				shift
				shift
			fi
			;;
		--pre-init-hooks)
			if [ -n "$2" ]; then
				pre_init_hook="$2"
			fi
			shift
			shift
			;;
		--additional-packages)
			if [ -n "$2" ]; then
				container_additional_packages="$2"
			fi
			shift
			shift
			;;
		--nvidia)
			if [ -n "$2" ]; then
				nvidia="$2"
				shift
				shift
			fi
			;;
		--)
			shift
			init_hook=$*
			break
			;;
		-*) # Invalid options.
			printf >&2 "Error: Invalid flag '%s'\n\n" "$1"
			show_help
			exit 1
			;;
		*) # Default case: If no more options then break out of the loop.
			break ;;
	esac
done

# Check we're running inside a container and not on the host
if [ ! -f /run/.containerenv ] && [ ! -f /.dockerenv ] && [ -z "${container:-}" ]; then
	printf >&2 "You must run %s inside a container!\n" " $(basename "$0")"
	printf >&2 "distrobox-init should only be used as an entrypoint for a distrobox!\n\n"
	printf >&2 "This is not intended to be used manually, but instead used by distrobox-enter\n"
	printf >&2 "to set up the container's entrypoint.\n"
	exit 126
fi

# Ensure the foundamental variables are set and not empty, we will not proceed if
# they are not all set.
if [ "${upgrade}" -eq 0 ]; then
	[ -z "${container_user_gid}" ] && printf "Error: Invalid arguments, missing user gid\n" && exit 2
	[ -z "${container_user_home}" ] && printf "Error: Invalid argument, missing user home\n" && exit 2
	[ -z "${container_user_name}" ] && printf "Error: Invalid arguments, missing username\n" && exit 2
	[ -z "${container_user_uid}" ] && printf "Error: Invalid arguments, missing user uid\n" && exit 2
fi
set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

# Add fallback values in case host's locale is not set correctly
if [ -z "${HOST_LOCALE:-}" ] || [ "${HOST_LOCALE:-}" = "C.UTF-8" ]; then
	HOST_LOCALE="en_US.UTF-8"
	HOST_LOCALE_ENCODING="UTF-8"
	HOST_LOCALE_LANG="en_US"
fi

# get_locked_mount_flags will print mount flags considered "locked".
# Arguments:
# 	src: path to the file/directory
# Expected env variables:
#	None
# Expected global variables:
#	None
# Outputs:
# 	Comma-separated list of locked mount flags
get_locked_mount_flags()
{
	src="$1"
	prev=""
	locked_flags=""

	# If findmnt does not exist, exit
	if ! command -v findmnt 2> /dev/null > /dev/null; then
		return 0
	fi

	# If we can't read the file/directory, exit
	if ! ls "${src}" 2> /dev/null > /dev/null; then
		return 0
	fi

	# Get mount flags of given file/directory, using nearest mountpoint.
	# Earlier versions of findmnt did not check parents until it found a mountpoint,
	# so we use a workaround with dirname.
	while true; do
		flags="$(findmnt --noheadings --output OPTIONS --target "${src}" || :)"
		# shellcheck disable=SC2181
		if [ -n "${flags}" ]; then
			break
		fi
		prev="${src}"
		src="$(dirname "${src}")"
		[ "${src}" = "${prev}" ] && return 1
	done

	for flag in nodev noexec nosuid; do
		if printf "%s" "${flags}" | grep -q "${flag}"; then
			# Locked flag found, append to list while avoiding leading/trailing commas
			locked_flags="${locked_flags:+${locked_flags},}${flag}"
		fi
	done

	printf "%s" "${locked_flags}"
}

# init_readlink is a simplistic implementation for
# readlink -fm
# we use this as readlink -fm does not work on
# busybox systems, and we need the path even for broken links.
# Arguments:
#	source file
# Expected env variables:
#	None
# Expected global variables:
#	None
# Outputs:
#	original path the link is pointing
init_readlink()
{
	# shellcheck disable=SC2010
	ls -l "${1}" | grep -Eo '\->.*' | cut -d' ' -f2- | sed 's|\.\./|/|g'
}

if [ -n "${pre_init_hook}" ]; then
	printf "distrobox: Executing pre-init hooks...\n"
	# execute pre-init hooks if specified
	# shellcheck disable=SC2086
	eval ${pre_init_hook}
fi

###############################################################################
printf "distrobox: Installing basic packages...\n"
# Extract shell name from the $SHELL environment variable
# If not present as package in the container, we want to install it.
shell_pkg="$(basename "${SHELL:-"bash"}")"
# Ash shell is an exception, it is not a standalone package, but part of busybox.
# for this reason, use this quirk to adjust the package name to standard bash.
if [ "${shell_pkg}" = "ash" ]; then
	shell_pkg="bash"
fi

# setup_apk will upgrade or setup all packages for apk based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_apk()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		apk update
		apk upgrade
		exit
	fi
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! apk add "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	if apk add wolfi-base; then
		deps="
			busybox
			gnutar
			man-db
			mesa
			openssh-client
			posix-libc-utils
		"
	elif apk add alpine-base; then
		deps="
			bash-completion
			docs
			gcompat
			libc-utils
			lsof
			man-pages
			mandoc
			musl-utils
			openssh-client-default
			pinentry
			tar
			vte3
			which
			$(apk search -q mesa-dri)
			$(apk search -q mesa-vulkan)
		"
	fi
	deps="${deps:-}
		${shell_pkg}
		bash
		bc
		bzip2
		coreutils
		curl
		diffutils
		findmnt
		findutils
		gnupg
		gpg
		iproute2
		iputils
		keyutils
		less
		libcap
		mount
		ncurses
		ncurses-terminfo
		net-tools
		pigz
		rsync
		shadow
		sudo
		tcpdump
		tree
		tzdata
		umount
		unzip
		util-linux
		util-linux-login
		util-linux-misc
		vulkan-loader
		wget
		xauth
		xz
		zip
		$(apk search -qe procps)
	"
	# shellcheck disable=SC2086
	found_deps="$(apk search -qe ${deps} | tr '\n' ' ')"
	install_pkg=""
	for dep in ${deps}; do
		# shellcheck disable=SC2249
		case " ${found_deps} " in
			*" ${dep} "*)
				install_pkg="${install_pkg} ${dep}"
				;;
		esac
	done
	# shellcheck disable=SC2086
	apk add --force-overwrite ${install_pkg}

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		apk del tzdata
		apk add tzdata
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		apk add --force-overwrite ${container_additional_packages}
	fi
}

# setup_apt will upgrade or setup all packages for apt based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_apt()
{
	export DEBIAN_FRONTEND=noninteractive

	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		apt-get update
		apt-get upgrade -o Dpkg::Options::="--force-confold" -y
		exit
	fi
	# In Ubuntu official images, dpkg is configured to ignore locale and docs
	# This however, results in a rather poor out-of-the-box experience
	# So, let's enable them.
	rm -f /etc/dpkg/dpkg.cfg.d/excludes

	apt-get update
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! apt-get install -y "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		${shell_pkg}
		apt-utils
		bash-completion
		bc
		bzip2
		curl
		dialog
		diffutils
		findutils
		gnupg
		gnupg2
		gpgsm
		hostname
		iproute2
		iputils-ping
		keyutils
		language-pack-en
		less
		libcap2-bin
		libkrb5-3
		libnss-mdns
		libnss-myhostname
		libvte-2.9*-common
		libvte-common
		locales
		lsof
		man-db
		manpages
		mtr
		ncurses-base
		openssh-client
		passwd
		pigz
		pinentry-curses
		procps
		rsync
		sudo
		tcpdump
		time
		traceroute
		tree
		tzdata
		unzip
		util-linux
		wget
		xauth
		xz-utils
		zip
		libgl1
		libegl-mesa0
		libegl1-mesa
		libgl1-mesa-glx
		libegl1
		libglx-mesa0
		libvulkan1
		mesa-vulkan-drivers
	"
	# shellcheck disable=SC2086,2046
	apt-get install -y $(apt-cache show ${deps} 2> /dev/null | grep "Package:" | sort -u | cut -d' ' -f2-)

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if [ -e /etc/locale.gen ] && {
		! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"
	}; then
		sed -i "s|#.*en_US.UTF-8|en_US.UTF-8|g" /etc/locale.gen
		sed -i "s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g" /etc/locale.gen
		locale-gen
		update-locale LC_ALL="${HOST_LOCALE}" LANG="${HOST_LOCALE}"
		dpkg-reconfigure locales
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		apt-get --reinstall install tzdata
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		apt-get install -y ${container_additional_packages}
	fi
}

# setup_dnf will upgrade or setup all packages for dnf/yum based systems.
# Arguments:
#   manager: yum or dnf
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_dnf()
{
	manager=$1

	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		${manager} upgrade -y
		exit
	fi
	# In dnf family official images, dnf is configured to ignore locale and docs
	# This however, results in a rather poor out-of-the-box experience
	# So, let's enable them.
	[ -e /etc/dnf/dnf.conf ] && sed -i '/tsflags=nodocs/d' /etc/dnf/dnf.conf
	[ -e /etc/yum.conf ] && sed -i '/tsflags=nodocs/d' /etc/yum.conf

	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! ${manager} install -y "${shell_pkg}" 2> /dev/null; then
		shell_pkg="bash"
	fi
	flags=""
	if [ "${manager}" = "dnf" ]; then
		flags="--allowerasing"
	fi
	deps="
		${shell_pkg}
		bash-completion
		bc
		bzip2
		cracklib-dicts
		curl
		diffutils
		dnf-plugins-core
		findutils
		glibc-all-langpacks
		glibc-common
		glibc-locale-source
		gnupg2
		gnupg2-smime
		hostname
		iproute
		iputils
		keyutils
		krb5-libs
		less
		lsof
		man-db
		man-pages
		mtr
		ncurses
		nss-mdns
		openssh-clients
		pam
		passwd
		pigz
		pinentry
		procps-ng
		rsync
		shadow-utils
		sudo
		tcpdump
		time
		traceroute
		tree
		tzdata
		unzip
		util-linux
		vte-profile
		wget
		which
		whois
		words
		xorg-x11-xauth
		xz
		zip
		mesa-dri-drivers
		mesa-vulkan-drivers
		vulkan
	"
	# shellcheck disable=SC2086,2046,2248
	${manager} install ${flags} -y $(${manager} list -q ${deps} |
		grep -v "Packages" |
		grep "$(uname -m)" |
		cut -d' ' -f1)

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if [ ! -e /usr/share/i18n/charmaps ]; then
		${manager} reinstall -y glibc-common
	fi
	if ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"; then
		LANG="${HOST_LOCALE}" localedef -i "${HOST_LOCALE_LANG}" -f "${HOST_LOCALE_ENCODING}" "${HOST_LOCALE}"
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		${manager} reinstall -y tzdata
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		${manager} install -y ${container_additional_packages}
	fi
}

# setup_emerge will upgrade or setup all packages for gentoo based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_emerge()
{
	# Check if the container we are using has a ::gentoo repo defined,
	# if it is defined and it is empty, then synchroznize it.
	gentoo_repo="$(portageq get_repo_path / gentoo)"
	if [ -n "${gentoo_repo}" ] && [ ! -e "${gentoo_repo}" ]; then
		emerge-webrsync
	fi
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		emerge --sync
		exit
	fi
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! emerge --ask=n --autounmask-continue --noreplace --quiet-build "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		app-shells/${shell_pkg}
		app-crypt/gnupg
		app-shells/bash-completion
		sys-apps/diffutils
		sys-apps/findutils
		sys-apps/less
		sys-libs/ncurses
		net-misc/curl
		app-crypt/pinentry
		sys-process/procps
		sys-apps/shadow
		app-admin/sudo
		sys-devel/bc
		sys-process/lsof
		sys-apps/util-linux
		net-misc/wget
	"
	install_pkg=""
	for dep in ${deps}; do
		if [ "$(emerge --ask=n --search "${dep}" | grep "Applications found" | grep -Eo "[0-9]")" -gt 0 ]; then
			# shellcheck disable=SC2086
			install_pkg="${install_pkg} ${dep}"
		fi
	done
	# shellcheck disable=SC2086
	emerge --ask=n --autounmask-continue --noreplace --quiet-build ${install_pkg}

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"; then
		sed -i "s|#.*en_US.UTF-8|en_US.UTF-8|g" /etc/locale.gen
		sed -i "s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g" /etc/locale.gen
		locale-gen
		cat << EOF > /etc/env.d/02locale
LANG=${HOST_LOCALE}
LC_CTYPE=${HOST_LOCALE}
EOF
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		emerge --ask=n --autounmask-continue --noreplace --quiet-build \
			${container_additional_packages}
	fi
}

# setup_microdnf will upgrade or setup all packages for microdnf based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_microdnf()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		microdnf upgrade -y
		exit
	fi
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! microdnf install -y "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		${shell_pkg}
		bash-completion
		bc
		bzip2
		cracklib-dicts
		diffutils
		dnf-plugins-core
		findutils
		glibc-all-langpacks
		glibc-common
		glibc-locale-source
		gnupg2
		gnupg2-smime
		hostname
		iproute
		iputils
		keyutils
		krb5-libs
		less
		lsof
		man-db
		man-pages
		mtr
		ncurses
		nss-mdns
		openssh-clients
		pam
		passwd
		pigz
		pinentry
		procps-ng
		rsync
		shadow-utils
		sudo
		tcpdump
		time
		traceroute
		tree
		tzdata
		unzip
		util-linux
		vte-profile
		wget
		which
		whois
		words
		xorg-x11-xauth
		xz
		zip
		mesa-dri-drivers
		mesa-vulkan-drivers
		vulkan
	"
	install_pkg=""
	for dep in ${deps}; do
		if [ "$(microdnf repoquery "${dep}" | wc -l)" -gt 0 ]; then
			install_pkg="${install_pkg} ${dep}"
		fi
	done
	# shellcheck disable=SC2086,SC2046
	microdnf install -y ${install_pkg}

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		microdnf reinstall -y tzdata || microdnf install -y glibc-common
	fi
	if ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"; then
		LANG="${HOST_LOCALE}" localedef -i "${HOST_LOCALE_LANG}" -f "${HOST_LOCALE_ENCODING}" "${HOST_LOCALE}"
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		microdnf reinstall -y tzdata || microdnf install -y tzdata
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		microdnf install -y ${container_additional_packages}
	fi
}

# setup_pacman will upgrade or setup all packages for pacman based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_pacman()
{
	# Update the package repository cache exactly once before installing packages.
	pacman -S -y -y

	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		pacman -S -u --noconfirm
		exit
	fi
	# In archlinux official images, pacman is configured to ignore locale and docs
	# This however, results in a rather poor out-of-the-box experience
	# So, let's enable them.
	sed -i "s|NoExtract.*||g" /etc/pacman.conf
	sed -i "s|NoProgressBar.*||g" /etc/pacman.conf

	pacman -S -u --noconfirm
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! pacman -S --needed --noconfirm "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		${shell_pkg}
		bash-completion
		bc
		curl
		diffutils
		findutils
		glibc
		gnupg
		iputils
		inetutils
		keyutils
		less
		lsof
		man-db
		man-pages
		mlocate
		mtr
		ncurses
		nss-mdns
		openssh
		pigz
		pinentry
		procps-ng
		rsync
		shadow
		sudo
		tcpdump
		time
		traceroute
		tree
		tzdata
		unzip
		util-linux
		util-linux-libs
		vte-common
		wget
		words
		xorg-xauth
		zip
		mesa
		vulkan-intel
		vulkan-radeon
	"
	# shellcheck disable=SC2086,2046
	pacman -S --needed --noconfirm $(pacman -Ssq | grep -E "^($(echo ${deps} | tr ' ' '|'))$")

	if [ ! -e "/usr/share/i18n/locales${HOST_LOCALE}" ]; then
		pacman -S --noconfirm glibc glibc-locales
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		pacman -S --noconfirm tzdata
	fi

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"; then
		sed -i "s|#.*en_US.UTF-8|en_US.UTF-8|g" /etc/locale.gen
		sed -i "s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g" /etc/locale.gen
		locale-gen -a
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		pacman -S --needed --noconfirm ${container_additional_packages}
	fi
}

# setup_slackpkg will upgrade or setup all packages for slackware based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_slackpkg()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		yes | slackpkg upgrade-all -default_answer=yes -batch=yes
		exit
	fi
	slackpkg update
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! yes | slackpkg install -default_answer=yes -batch=yes "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		${shell_pkg}
		bash-completion
		bc
		curl
		diffutils
		findutils
		glew
		glibc
		glu
		gnupg2
		iputils
		less
		libX11
		libXau
		libXdamage
		libXdmcp
		libXext
		libXfixes
		libXxf86vm
		libdrm
		libvte-2
		libxcb
		libxcb-dri2
		libxcb-dri3
		libxcb-glx
		libxcb-present
		libxcb-randr
		libxcb-render
		libxcb-shape
		libxcb-sync
		libxcb-xfixes
		libxshmfence
		lsof
		man
		mesa
		ncurses
		openssh
		pinentry
		procps
		rsync
		shadow
		ssh
		sudo
		time
		wget
		xauth
	"
	install_pkg=""
	dep=""
	for dep in ${deps}; do
		if ! slackpkg search "${dep}" | grep -q "No package name matches the pattern"; then
			install_pkg="${install_pkg} ${dep}"
		fi
	done

	rm -f /var/lock/slackpkg.*

	# shellcheck disable=SC2086
	yes | slackpkg install -default_answer=yes -batch=yes ${install_pkg}

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		yes | slackpkg install -default_answer=yes -batch=yes \
			${container_additional_packages}
	fi
}

# setup_swupd will upgrade or setup all packages for clearlinux based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_swupd()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		swupd update
		exit
	fi

	swupd bundle-add os-core-search

	deps="
		bc
		cryptography
		curl
		network-basic
		procps-ng
		rsync
		shells
		sysadmin-basic
		unzip
		wget
		x11-tools
		zip
		devpkg-Vulkan-Loader
		lib-opengl
	"
	install_pkg=""
	for dep in ${deps}; do
		if swupd search "${dep}" > /dev/null; then
			install_pkg="${install_pkg} ${dep}"
		fi
	done
	# shellcheck disable=SC2086
	swupd bundle-add ${install_pkg}

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		swupd bundle-add ${container_additional_packages}
	fi
}

# setup_xbps will upgrade or setup all packages for xbps based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_xbps()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		xbps-install -Syu
		exit
	fi
	# Ensure we avoid errors by keeping xbps updated
	xbps-install -Syu xbps

	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	if ! xbps-install -Sy "${shell_pkg}"; then
		shell_pkg="bash"
	fi
	deps="
		${shell_pkg}
		bash-completion
		bc
		bzip2
		curl
		diffutils
		findutils
		gnupg2
		inetutils-ping
		iproute2
		less
		lsof
		man-db
		mit-krb5-client
		mit-krb5-libs
		mtr
		ncurses-base
		nss
		openssh
		pigz
		pinentry-tty
		procps-ng
		rsync
		shadow
		sudo
		time
		traceroute
		tree
		tzdata
		unzip
		util-linux
		xauth
		xz
		zip
		wget
		vte3
		mesa-dri
		vulkan-loader
		mesa-vulkan-intel
		mesa-vulkan-radeon
	"
	# shellcheck disable=SC2086,2046
	xbps-install -Sy $(xbps-query -Rs '*' | awk '{print $2}' | sed 's/-[^-]*$//' | grep -E "^($(echo ${deps} | tr ' ' '|'))$")

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if command -v locale && {
		! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"
	}; then
		sed -i "s|#.*en_US.UTF-8|en_US.UTF-8|g" /etc/default/libc-locales
		sed -i "s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g" /etc/default/libc-locales
		xbps-reconfigure --force glibc-locales
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		xbps-install --force -y tzdata
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		xbps-install -Sy ${container_additional_packages}
	fi
}

# setup_zypper will upgrade or setup all packages for zypper based systems.
# Arguments:
#   None
# Expected global variables:
#   upgrade: if we need to upgrade or not
#   container_additional_packages: additional packages to install during this phase
# Expected env variables:
#   None
# Outputs:
#   None
setup_zypper()
{
	# If we need to upgrade, do it and exit, no further action required.
	if [ "${upgrade}" -ne 0 ]; then
		zypper dup -y
		exit
	fi
	if ! zypper install -y "${shell_pkg}"; then
		shell_pkg="bash"
	fi

	# In openSUSE official images, zypper is configured to ignore recommended
	# packages (i.e., weak dependencies). This however, results in a rather
	# poor out-of-the-box experience (e.g., when trying to run GUI apps).
	# So, let's enable them. For the same reason, we make sure we install
	# docs.
	sed -i 's/.*solver.onlyRequires.*/solver.onlyRequires = false/g' /etc/zypp/zypp.conf
	sed -i 's/.*rpm.install.excludedocs.*/rpm.install.excludedocs = no/g' /etc/zypp/zypp.conf
	# With recommended packages, something might try to pull in
	# parallel-printer-support which can't be installed in rootless containers.
	# Since we very much likely never need it, just lock it
	zypper al parallel-printer-support
	# Check if shell_pkg is available in distro's repo. If not we
	# fall back to bash, and we set the SHELL variable to bash so
	# that it is set up correctly for the user.
	deps="
		${shell_pkg}
		bash-completion
		bc
		bzip2
		curl
		diffutils
		findutils
		glibc-locale
		glibc-locale-base
		gnupg
		hostname
		iputils
		keyutils
		less
		libvte-2*
		lsof
		man
		man-pages
		mtr
		ncurses
		nss-mdns
		openssh-clients
		pam
		pam-extra
		pigz
		pinentry
		procps
		rsync
		shadow
		sudo
		system-group-wheel
		systemd
		time
		timezone
		tree
		unzip
		util-linux
		util-linux-systemd
		wget
		words
		xauth
		zip
		Mesa-dri
		libvulkan1
		libvulkan_intel
		libvulkan_radeon
	"
	# Mark gpg errors (exit code 106) as non-fatal, but don't pull anything from unverified repos
	# shellcheck disable=SC2086,SC2046
	zypper -n install -y $(zypper -n -q se --match-exact ${deps} | grep -e 'package$' | cut -d'|' -f2) || [ ${?} = 106 ]

	# In case the locale is not available, install it
	# will ensure we don't fallback to C.UTF-8
	if ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi "$(echo "${HOST_LOCALE}" | tr -d '-')"; then
		LANG="${HOST_LOCALE}" localedef -i "${HOST_LOCALE_LANG}" -f "${HOST_LOCALE_ENCODING}" "${HOST_LOCALE}" || true
	fi

	# Ensure we have tzdata installed and populated, sometimes container
	# images blank the zoneinfo directory, so we reinstall the package to
	# ensure population
	if [ ! -e /usr/share/zoneinfo/UTC ]; then
		zypper install -f -y timezone
	fi

	# Install additional packages passed at distrbox-create time
	if [ -n "${container_additional_packages}" ]; then
		# shellcheck disable=SC2086
		zypper install -y ${container_additional_packages}
	fi
}

# Check dependencies in a list, and install all if one is missing
missing_packages=0
dependencies="
	bc
	bzip2
	chpasswd
	curl
	diff
	find
	findmnt
	gpg
	hostname
	less
	lsof
	man
	mount
	passwd
	pigz
	pinentry
	ping
	ps
	rsync
	script
	ssh
	sudo
	time
	tree
	umount
	unzip
	useradd
	wc
	wget
	xauth
	zip
	${shell_pkg}
"
for dep in ${dependencies}; do
	! command -v "${dep}" > /dev/null && missing_packages=1 && break
done

# Ensure we have the least minimal path of standard Linux File System set
PATH="${PATH}:/bin:/sbin:/usr/bin:/usr/sbin"

# Check if dependencies are met for the script to run.
if [ "${upgrade}" -ne 0 ] ||
	[ "${missing_packages}" -ne 0 ] ||
	{
		[ -n "${container_additional_packages}" ] && [ ! -e /.containersetupdone ]
	}; then

	# Detect the available package manager
	# install minimal dependencies needed to bootstrap the container:
	#	the same shell that's on the host + ${dependencies}
	if command -v apk; then
		setup_apk
	elif command -v apt-get; then
		setup_apt
	elif command -v emerge; then
		setup_emerge
	elif command -v pacman; then
		setup_pacman
	elif command -v slackpkg; then
		setup_slackpkg
	elif command -v swupd; then
		setup_swupd
	elif command -v xbps-install; then
		setup_xbps
	elif command -v zypper; then
		setup_zypper
	elif command -v dnf; then
		setup_dnf dnf
	elif command -v microdnf; then
		setup_microdnf
	elif command -v yum; then
		setup_dnf yum
	else
		printf "Error: could not find a supported package manager.\n"
		printf "Error: could not set up base dependencies.\n"
		# Exit as command not found
		exit 127
	fi

	touch /.containersetupdone
fi

# Set SHELL to the install path inside the container
SHELL="$(command -v "${shell_pkg}")"

###############################################################################

# Ensure compatibility with older versions of su, this will allow to specify
# the --pty flag
#
# This won't work well on very old distros with no flag support, but will give
# an usable shell nonetheless
if ! su --help | grep -q pty; then
	cat << EOF > /usr/local/bin/su
#!/bin/sh

for i do
  [ "\$i" = --pty ] || set -- "\$@" "\$i"
  shift
done

/bin/su "\$@"
EOF
	chmod +x /usr/local/bin/su
fi

###############################################################################

printf "distrobox: Setting up distrobox profile...\n"

# This ensures compatibility with prompts and tools between toolbx and distrobox
touch /run/.toolboxenv

# Ensure we have some basic env variables and prompt as base if /etc/profile.d is missing
if [ ! -d /etc/profile.d ]; then
	rcfiles="
		/etc/profile
		/etc/bash.bashrc
		/etc/bashrc
		/etc/zshrc
	"
	for rcfile in ${rcfiles}; do
		if [ -e "${rcfile}" ] && ! grep -q 'distrobox_profile.sh' "${rcfile}"; then
			echo "[ -e /etc/profile.d/distrobox_profile.sh ] && . /etc/profile.d/distrobox_profile.sh" >> "${rcfile}"
		fi
	done
	mkdir -p /etc/profile.d
fi
cat << EOF > /etc/profile.d/distrobox_profile.sh
test -z "\$USER" && export USER="\$(id -un 2> /dev/null)"
test -z "\$UID"  && readonly UID="\$(id -ur 2> /dev/null)"
test -z "\$EUID" && readonly EUID="\$(id -u  2> /dev/null)"
export SHELL="\$(getent passwd "\${USER}" | cut -f 7 -d :)"

test -z "\${XDG_RUNTIME_DIR:-}" && export XDG_RUNTIME_DIR="/run/user/\$(id -ru)"
test -z "\${DBUS_SESSION_BUS_ADDRESS:-}" && export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/\$(id -ru)/bus"

# This will ensure a default prompt for a container, this will be remineshent of
# toolbx prompt: https://github.com/containers/toolbox/blob/main/profile.d/toolbox.sh#L47
# this will ensure greater compatibility between the two implementations
if [ -f /run/.toolboxenv ]; then
    [ "\${BASH_VERSION:-}" != "" ] && export PS1="üîíüì¶[\u@\$CONTAINER_ID \W]\$ "
    [ "\${ZSH_VERSION:-}" != "" ] && export PS1="üîíüì¶[%n@\$CONTAINER_ID]%~%# "
fi

# This will ensure we have a first-shell password setup for an user if needed.
# We're going to use this later in case of rootful containers
if [ -e /var/tmp/.\$USER.passwd.initialize ]; then
	echo "‚ö†Ô∏è  First time user password setup ‚ö†Ô∏è "
	trap "echo; exit" INT
	passwd && rm -f /var/tmp/.\$USER.passwd.initialize
	trap - INT
fi
EOF

# It's also importanto to keep this working on fish shells
if [ -e "/etc/fish/config.fish" ]; then
	mkdir -p /etc/fish/conf.d
	cat << EOF > /etc/fish/conf.d/distrobox_config.fish
if status --is-interactive
	test -z "\$USER" && set -gx USER (id -un 2> /dev/null)
	test -z "\$UID"  && set -gx UID (id -ur 2> /dev/null)
	test -z "\$EUID" && set -gx EUID (id -u  2> /dev/null)
	set -gx SHELL (getent passwd "\$USER" | cut -f 7 -d :)

	test -z "\$XDG_RUNTIME_DIR && set -gx XDG_RUNTIME_DIR /run/user/(id -ru)
	test -z "\$DBUS_SESSION_BUS_ADDRESS && set -gx DBUS_SESSION_BUS_ADDRESS unix:path=/run/user/(id -ru)/bus

	# This will ensure we have a first-shell password setup for an user if needed.
	# We're going to use this later in case of rootful containers
	if test -e /var/tmp/.\$USER.passwd.initialize
		echo "‚ö†Ô∏è  First time user password setup ‚ö†Ô∏è "
		trap "echo; exit" INT
		passwd && rm -f /var/tmp/.\$USER.passwd.initialize
		trap - INT
	end
	function fish_prompt
		set current_dir (basename (pwd))
		echo "üì¶[\$USER@\$CONTAINER_ID \$current_dir]> "
	end
end
EOF
fi
###############################################################################

###############################################################################
printf "distrobox: Setting up sudo...\n"
mkdir -p /etc/sudoers.d
# Ensure we're using the user's password for sudo, not root
if [ -e /etc/sudoers ]; then
	sed -i "s|^Defaults targetpw.*||g" /etc/sudoers
fi

# Do not check fqdn when doing sudo, it will not work anyways
# Also allow canonical groups to use sudo
cat << EOF > /etc/sudoers.d/sudoers
Defaults !targetpw
Defaults !fqdn
%wheel ALL=(ALL:ALL) ALL
%sudo ALL=(ALL:ALL) ALL
%root ALL=(ALL:ALL) ALL
EOF

# PAM config for "su" command
if [ ! -e /etc/pam.d/su ]; then
	mkdir -p /etc/pam.d
	cat << EOF > /etc/pam.d/su
auth            sufficient      pam_rootok.so
auth            required        pam_unix.so
account	        required        pam_unix.so
session         required        pam_unix.so
-session        optional        pam_systemd.so
EOF
fi

if ! grep -q "pam_systemd.so" /etc/pam.d/su; then
	printf "%s" '-session   optional   pam_systemd.so' >> /etc/pam.d/su
fi

# If we're running this script as root in a login shell (sudoless), we don't
# have to bother setting up sudo.
#
# Also if we're in a rootful container, we will setup user's password,
# so let's skip passwordless sudo too
if [ "${container_user_uid}" -ne 0 ] && [ "${rootful}" -eq 0 ]; then
	# Ensure passwordless sudo is set up for user
	printf "\"%s\" ALL = (root) NOPASSWD:ALL\n" "${container_user_name}" >> /etc/sudoers.d/sudoers
fi
###############################################################################

###############################################################################
# If not existing, ensure we have a group for our user.
if ! grep -q "^${container_user_name}:" /etc/group; then
	printf "distrobox: Setting up user groups...\n"

	if ! groupadd --force --gid "${container_user_gid}" "${container_user_name}"; then
		# It may occur that we have users with unsupported user name (eg. on LDAP or AD)
		# So let's try and force the group creation this way.
		printf "%s:x:%s:" "${container_user_name}" "${container_user_gid}" >> /etc/group
	fi
fi
###############################################################################

###############################################################################

printf "distrobox: Setting up user's group list...\n"
# If we have sudo/wheel groups, let's add the user to them.
# and ensure that user's in those groups can effectively sudo
additional_groups=""
if grep -q "^sudo" /etc/group; then
	additional_groups="sudo"
elif grep -q "^wheel" /etc/group; then
	additional_groups="wheel"
elif grep -q "^root" /etc/group; then
	additional_groups="root"
fi

# Let's add our user to the container. if the user already exists, enforce properties.
#
# In case of AD or LDAP usernames, it is possible we will have a backslach in the name.
# In that case grep would fail, so we replace the backslash with a point to make the regex work.
# shellcheck disable=SC1003
if ! grep -q "^$(printf '%s' "${container_user_name}" | tr '\\' '.'):" /etc/passwd &&
	! getent passwd "${container_user_uid}"; then
	printf "distrobox: Adding user...\n"
	if ! useradd \
		--home-dir "${container_user_home}" \
		--no-create-home \
		--groups "${additional_groups}" \
		--shell "${SHELL:-"/bin/bash"}" \
		--uid "${container_user_uid}" \
		--gid "${container_user_gid}" \
		"${container_user_name}"; then

		printf "Warning: There was a problem setting up the user with usermod, trying manual addition\n"

		printf "%s:x:%s:%s:%s:%s:%s" \
			"${container_user_name}" "${container_user_uid}" \
			"${container_user_gid}" "${container_user_name}" \
			"${container_user_home}" "${SHELL:-"/bin/bash"}" >> /etc/passwd
		printf "%s::1::::::" "${container_user_name}" >> /etc/shadow
	fi
# Ensure we're not using the specified SHELL. Run it only once, so that future
# user's preferences are not overwritten at each start.
elif [ ! -e /etc/passwd.done ]; then
	# This situation is presented when podman or docker already creates the user
	# for us inside container. We should modify the user's prepopulated shadowfile
	# entry though as per user's active preferences.

	# If the user was there with a different username, get that username so
	# we can modify it
	if ! grep -q "^$(printf '%s' "${container_user_name}" | tr '\\' '.'):" /etc/passwd; then
		user_to_modify=$(getent passwd "${container_user_uid}" | cut -d: -f1)
	fi

	printf "distrobox: Setting up existing user...\n"
	if ! usermod \
		--home "${container_user_home}" \
		--shell "${SHELL:-"/bin/bash"}" \
		--groups "${additional_groups}" \
		--uid "${container_user_uid}" \
		--gid "${container_user_gid}" \
		--login "${container_user_name}" \
		"${user_to_modify:-"${container_user_name}"}"; then

		printf "Warning: There was a problem setting up the user with usermod, trying manual addition\n"

		# Modify the user
		printf "distrobox: Setting up existing user: /etc/passwd...\n"
		sed -i "s|^${container_user_name}.*||g" /etc/passwd
		printf "%s:x:%s:%s:%s:%s:%s" \
			"${container_user_name}" "${container_user_uid}" \
			"${container_user_gid}" "${container_user_name}" \
			"${container_user_home}" "${SHELL:-"/bin/bash"}" >> /etc/passwd

		# Add or modify the default group
		# and add or modify the additional groups
		printf "distrobox: Setting up existing user: /etc/group...\n"
		for group in ${container_user_name} ${additional_groups}; do
			# Check if we have the user in the group
			if ! grep -q "^${group}.*${container_user_name}.*" /etc/group; then
				group_line="$(grep "^${group}.*" /etc/group)"
				# If no users in the group just add it
				if grep -q "^${group}.*:$" /etc/group; then
					sed -i "s|${group_line}|${group_line}${container_user_name}|g" /etc/group
				else
					sed -i "s|${group_line}|${group_line},${container_user_name}|g" /etc/group
				fi
			fi
		done
	fi
fi

# Ensure we have our home correctly set, in case of cloned containers or whatnot
if [ "$(getent passwd "${container_user_name}" | cut -d: -f6)" != "${container_user_home}" ]; then
	printf "distrobox: Setting up user home...\n"

	if ! usermod -d "${container_user_home}" "${container_user_name}"; then
		sed -i "s|^${container_user_name}.*|${container_user_name}:x:${container_user_uid}:${container_user_gid}::${container_user_home}:${SHELL:-"/bin/bash"}|g" /etc/passwd
	fi
fi

# If we're rootless, delete password for root and user
if [ ! -e /etc/passwd.done ]; then
	printf "distrobox: Ensuring user's access...\n"

	temporary_password="$(md5sum < /proc/sys/kernel/random/uuid | cut -d' ' -f1)"
	# We generate a random password to initialize the entry for the user.
	chpasswd_failed=0
	printf "%s:%s" "${container_user_name}" "${temporary_password}" | chpasswd -e || chpasswd_failed=1
	printf "%s:" "${container_user_name}" | chpasswd -e || chpasswd_failed=1

	if [ "${chpasswd_failed}" -eq 1 ]; then
		printf "Warning: There was a problem setting up the user, trying manual addition\n"
		if grep -q "${container_user_name}" /etc/shadow; then
			sed -i "s|^${container_user_name}.*|${container_user_name}::::::::|g" /etc/shadow
		else
			echo "${container_user_name}::::::::" >> /etc/shadow
		fi
	fi

	if [ "${rootful}" -eq 0 ]; then
		# We're rootless so we don't care about account password, so we remove it
		passwd_cmd=passwd
		if passwd --help 2>&1 | grep -q -- --stdin; then
			passwd_cmd="passwd --stdin"
		fi
		printf "%s\n%s\n" "${temporary_password}" "${temporary_password}" | ${passwd_cmd} root
		printf "%s:" "root" | chpasswd -e
	else
		# We're rootful, so we don't want passwordless accounts, so we lock them
		# down by default.

		# lock out root user
		if ! usermod -L root; then
			sed -i 's|^root.*|root:!:1::::::|g' /etc/shadow
		fi
	fi
fi

# If we are in a rootful container, let's setup a first-shell password setup
# so that sudo, and su has a password
#
# else we fallback to the usual setup with passwordless sudo/su user. This is
# likely because we're in a rootless setup, so privilege escalation is not a concern.
if [ "${rootful}" -eq 1 ] &&
	{
		[ "$(grep "${container_user_name}" /etc/shadow | cut -d':' -f2)" = '!!' ] ||
			[ "$(grep "${container_user_name}" /etc/shadow | cut -d':' -f2)" = "" ]
	}; then

	# force setup of user's password on first shell
	if [ ! -e /var/tmp ]; then
		mkdir -p /var/tmp
		chmod 0777 /var/tmp
	fi
	touch /var/tmp/."${container_user_name}".passwd.initialize
	chown "${container_user_name}:${container_user_gid}" /var/tmp/."${container_user_name}".passwd.initialize
fi

# Now we're done
touch /etc/passwd.done
###############################################################################

###############################################################################
if [ -n "${DISTROBOX_HOST_HOME-}" ] && [ -d "/etc/skel" ]; then
	printf "distrobox: Setting up skel...\n"

	# If we do not have profile files in the home, we should copy the
	# skeleton files, if present.
	# Ensure we copy only if the dotfile is not already present.
	skel_files="$(find /etc/skel/ -type f || :)"
	for skel_file in ${skel_files}; do
		base_file_name=$(basename "${skel_file}")
		skel_file_path=$(dirname "${skel_file}")
		file_path_for_home=${skel_file_path#/etc/skel}

		if [ -n "${file_path_for_home}" ] &&
			[ ! -d "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"}" ]; then
			mkdir -p "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}"
			chown "${container_user_uid}":"${container_user_gid}" "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}"
		fi

		if [ ! -f "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}${base_file_name}" ] &&
			[ ! -L "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}${base_file_name}" ]; then
			cp "${skel_file}" "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}${base_file_name}"
			chown "${container_user_uid}":"${container_user_gid}" "${container_user_home}/${file_path_for_home:+"${file_path_for_home}"/}${base_file_name}"
		fi

	done
fi
###############################################################################

###############################################################################
if [ -n "${init_hook}" ]; then
	printf "distrobox: Executing init hooks...\n"
	# execute eventual init hooks if specified
	# shellcheck disable=SC2086
	eval ${init_hook}
fi
###############################################################################
printf "container_setup_done\n"
sleep infinity